## 상속

> 범용적인 개념에서 더 구체적인 개념을 만들 때 사용한다.

### 1. 상속의 개요

- 클래스 간의 관계를 설명할 때 일반적으로 UML을 사용
- UML: 클래스와 객체 간의 관계를 시각적으로 나타내는 단어
- 슈퍼 클래스 or 베이스 클래스: 범용적인 클래스 / 파생 클래스 or 서브 클래스: 구체적인 클래스
- 파생 클래스는 베이스 클래스를 확장한 것
- 파생 클래스는 슈퍼 클래스의 모든 데이터 멤버와 멤버 함수를 보유 (생성자, 소멸자, 할당 연산자는 제외) + 추가적인 데이터 멤버 및 멤버 함수를 가짐
- 파생 클래스를 만들 때 public, protected, private라는 3가지 선택지 존재 &rarr; 클래스 이름 뒤에 `:`을 입력하고 접근 제한자 및 베이스 클래스 이름을 붙여서 만들게 됨
- 상속의 종류를 지정하지 않는 경우 private 상속이 디폴트, 하지만 잘 사용하지 않기 때문에 접근 제한자의 종류를 명시하는 것이 일반적
- 주로 public 상속을 많이 사용함

### 2. public 상속

- public 과 private의 상관 관계

  - 자바와 같은 다른 프로그래밍 언어들은 protected, private 상속이 없는 경우가 많음

  - 파생 클래스에서 상속된 private 데이터 멤버에 접근하려면 베이스클래스에서 상속된 public 멤버 함수를 통해 접근해야 함

  - 위임: 파생 클래스에서 베이스 클래스의 함수를 호출해서 어떤 작업을 하게 하는 것

  - 베이스 클래스의 멤버 함수를 **위임을 목적으로 호출할 때** 클래스 스코프 연산자를 활용

- 오버로드와 오버라이드

  - 베이스 클래스에 존재하는 멤버 함수와 동일한 이름의 함수를 만들고 싶을 때 사용

  - 멤버 함수 오버로드 (함수의 시그니처가 다른 경우): 2개의 함수를 모두 사용할 수 있음

    ```cpp
    void set(long identity);	// Person 클래스
    void set(double gpa);			// Student 클래스
    ```

  - 멤버 함수 오버라이드: 이름도 같고, 시그니처도 같은 함수를 만들 경우

  - 클래스 스코프

    - 파생 클래스에서 베이스 클래스에 정의되어 있는 이름을 볼 수 있음

    - 베이스 클래스는 파생 클래스에 정의되어 있는 이름을 볼 수 없음

    - 컴파일러 탐색 규칙

      - 컴파일러는 멤버 함수를 호출한 객체의 클래스에서 이름과 매개변수가 같은 함수를 탐색
      - 찾지 못한 경우, 베이스 클래스에서 이름과 매개변수가 같은 함수를 탐색
      - 찾지 못한 경우, 베이스 클래스의 베이스 클래스를 타고 올라가며 탐색
      - 상속 계층 전체에서 찾지 못하면, 컴파일 오류 발생

    - 상속되지 않은 멤버

      - 기본 생성자, 매개 변수가 있는 생성자, 복사 생성자, 소멸자, 할당 연산자

      - 파생 클래스는 일반적으로 베이스 클래스보다 많은 데이터 멤버를 가지므로 생성자와 소멸자가 상속되지 않음

      - 파생 클래스의 멤버 함수에서 베이스 클래스의 private 데이터 멤버를 소멸시킬 수 없음 등등

        &rarr; 생성자: 베이스 생성자 호출 후 파생 클래스의 데이터 멤버 초기화

        &rarr; 소멸자: 파생 클래스의 데이터 멤버 제거 후 베이스 소멸자 호출

    - 분할 컴파일
      - 파생 클래스만 단독으로 컴파일되는 경우, 별도의 엔티티로 나오게 됨

### 3. 상속의 접근과 막기

- protected 멤버
  - 베이스 클래스에서는 private 멤버처럼 작동하며 파생 클래스에서는 public 멤버처럼 작동
  - 파생 클래스에서 따로 간접 접근할 필요 없이 직접 접근이 가능
- private 데이터 멤버 사용하기
  - 캡슐화를 유지할 수 있음
  - 클래스 외부의 모든 곳에서 데이터 멤버에 접근할 수 없음
  - 데이터 멤버에 접근하려면 추가적인 코드 필요
- protected 데이터 멤버 사용하기
  - 캡슐화를 깨뜨리는 문제 보유
  - 클래스 설계의 복잡성이 너무 커질 경우 고려할 수 있음
  - 상속 막기
    - final 한정자를 사용하여 추가적인 상속을 차단
  - 상속 트리
    - 상속 관계를 그림으로 나타낸 것
    - 클래스가 더 파생될 경우 더 큰 상속트리가 만들어짐

